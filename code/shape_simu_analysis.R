################################################################################
## Project  : CAPoly shape clustering project
## Goal     : Clustering analysis on shapes
## Data     : Simulated data generated by Jin, Kevin Wang
## Modified : 2022-09-30
################################################################################

rm(list = ls())
data_name <- "decagons"

## Used functions ##############################################################
## Organizing label 
organize_label = function(z) {
  z_new <- rep(NA, length(z))
  data <- 1
  for(k in unique(z)) {
    z_new[z == k] <- data
    data <- data + 1
  }
  return (z_new)
}

## Function to get estimated clusters using pairwise probability matrix (PPM)
get.ppm <- function(z_store, burn, iter, K) {
  library(mcclust)
  ppm <- matrix(0, nrow = n, ncol = n);
  
  for (ii in (burn + 1):iter) {
    for (i in 1:(n - 1)) {
      for (j in (i + 1):n) {
        if (z_store[ii, i] == z_store[ii, j]) {
          ppm[i, j] <- ppm[i, j] + 1;
          ppm[j, i] <- ppm[j, i] + 1;
        }
      }
    }
  }
  
  ppm <- ppm/(iter - burn);
  diag(ppm) <- rep(1, n);
  
  z_ppm <- minbinder(ppm, method = "comp", max.k = K)$cl
  return(list(z_ppm = z_ppm, ppm = ppm))
  
}


## Evaluate results using adjusted Rand index (ARI) 
ari <- function(zt, z) {
  library(mclust)
  return(adjustedRandIndex(zt, z))
  
}


## Shape detection analysis ####################################################
link <- "~/Documents/Programming/Repositories/BACON/data/simulated/"
setwd("~/Documents/Programming/Repositories/BACON/code")
library(MCMCpack)    ## for function rdirichlet()

load(paste0(link, "Data/decagons.Rdata"))
X = angles[, 1:20]
Y = side_lengths[, 1:20]
true_cluster = angles[, "clusters"]
n = nrow(X)
p = ncol(X)
K = length(unique(true_cluster))


# ## Summary statistics ##########################################################
colMeans(X)
apply(X, 2, var)
colMeans(Y)
apply(Y, 2, var)
# library(gdatas)
# library(dplyr)
# CrossTable(true_cluster)
# tt <- data.frame("Cluster" = true_cluster)
# tt$Cluster <- as.factor(tt$Cluster)
# 
# df <- tt %>%
#   group_by(Cluster) %>% # Variable to be transformed
#   count() %>%
#   ungroup() %>%
#   mutate(perc = `n` / sum(`n`)) %>%
#   arrange(perc) %>%
#   mutate(labels = scales::percent(perc))
# 
# 
# p1 <- ggplot(df, aes(x = "", y = perc, fill = Cluster)) +
#   geom_col(color = "black") +
#   geom_label(aes(label = labels), color = c("white", "white", "white", "black"),
#              position = position_stack(vjust = 0.5),
#              show.legend = FALSE) +
#   guides(fill = guide_legend(title = "Cluster")) +
#   scale_fill_viridis_d() +
#   coord_polar(theta = "y") +
#   theme_void()
# 
# print(p1)
# 
# png(paste0(link, "Report/Figure/", data_name, "_pie.png"), width = 2000, height = 2000, res = 300)
# grid.arrange(p1, nrow = 1)
# dev.off()
# 
# ## Boxplots of angles data
# png(paste0(link, "Report/Figure/", data_name, "_angles_boxplot.png"), width = 2500, height = 1000, res = 300)
# par(mfrow = c(2, 5))
# par(mar = c(4, 4, 0.5, 0.5))
# for (j in 1:p) {
#   boxplot(X[, j] ~ true_cluster, xlab = "Cluster", ylab = paste0("Variable ", j))
# }
# dev.off()
# 
# ## Boxplots of side length data
# png(paste0(link, "Report/Figure/", data_name, "_length_boxplot.png"), width = 2500, height = 1000, res = 300)
# par(mfrow = c(2, 5))
# par(mar = c(4, 4, 0.5, 0.5))
# for (j in 1:p) {
#   boxplot(Y[, j] ~ true_cluster, xlab = "Cluster", ylab = paste0("Variable ", j))
# }
# dev.off()
# 
# 
# ## UMAP ########################################################################
# library(umap)
# library(ggplot2)
# library(gridExtra)
# library(ggpubr)
# x.umap <- umap(X)
# tt <- as.data.frame(x.umap$layout)
# names(tt) <- c("UMAP1", "UMAP2")
# tt$Cluster <- as.factor(true_cluster)
# p1 <- ggplot(tt, aes(x = UMAP1, y = UMAP2, col = Cluster)) + geom_point(size = 0.5) +
#   ggtitle("Angles") +
#   theme(plot.title = element_text(hjust = 0.5, size = 10)) 
# print(p1)
# 
# x.umap <- umap(Y)
# tt <- as.data.frame(x.umap$layout)
# names(tt) <- c("UMAP1", "UMAP2")
# tt$Cluster <- as.factor(true_cluster)
# p2 <- ggplot(tt, aes(x = UMAP1, y = UMAP2, col = Cluster)) + geom_point(size = 0.5) +
#   ggtitle("Side length") +
#   theme(plot.title = element_text(hjust = 0.5, size = 10))
# 
# x.umap <- umap(cbind(X, Y))
# tt <- as.data.frame(x.umap$layout)
# names(tt) <- c("UMAP1", "UMAP2")
# tt$Cluster <- as.factor(true_cluster)
# p3 <- ggplot(tt, aes(x = UMAP1, y = UMAP2, col = Cluster)) + geom_point(size = 0.5) +
#   ggtitle("Combination of angles and side lengths") +
#   theme(plot.title = element_text(hjust = 0.5, size = 10)) 
# 
# png(paste0(link, "Report/", "Figure/", data_name, "_angle_length_umap.png"), width = 3000, height = 1000, res = 300)
# ggarrange(p1, p2, p3, nrow=1, common.legend = TRUE, legend="bottom")
# dev.off()


## Algorithm settings ##########################################################
software <- "Rcpp"
if (software == "R"){
  source("shape_mcmc.R")
}else{
  Rcpp::sourceCpp("shape_mcmc.cpp")
}
iter <- 10000
burn <- iter/2

for (data in c("angles")) {
  set.seed(1000)
  if (data == "angles"){
    z_kmeans <- kmeans(X, centers = K)$cluster
  }else if(data == "side_lengths"){
    z_kmeans <- kmeans(Y, centers = K)$cluster
  }else{
    z_kmeans <- kmeans(cbind(X, Y), centers = K)$cluster
  }
  
  z_kmeans <- organize_label(z_kmeans)
  (ari_kmeans <- ari(true_cluster, z_kmeans))

  ## Hierarchical Clustering
  if (data == "angles"){
    distance_mat <- dist(X, method = 'euclidean')
  }else if (data == "side_lengths"){
    distance_mat <- dist(Y, method = 'euclidean')
  }else{
    distance_mat <- dist(cbind(X,Y), method = 'euclidean')
  }
  
  tt <- hclust(distance_mat, method = "complete")

  ## Compute ARI
  z_hclust <- cutree(tt, k = K)
  ari_hclust <- ari(true_cluster, z_hclust)
  
  ## Model-based clustering 
  if (data == "angles"){
    GMM = Mclust(X, G = K)
  }else if (data == "side_lengths"){
    GMM = Mclust(Y, G = K)
  }else{
    GMM = Mclust(cbind(X, Y), G = K)
  }  
  
  z_mclust <- GMM$classification
  ari_mclust <- ari(true_cluster, z_mclust)
  
  message(paste0("data name = ", data_name, "; data = ", data, "; T = ", iter,  "; K-means = ", round(ari_kmeans, digits = 3)))
  
  
  ## MCMC algorithm ##############################################################
  start_time = proc.time()
  if (data == "both"){
    mcmc_result = mcmc(X, Y, organize_label(z_mclust), "TRUE", 2, iter, burn)
  }else if (data == "angles"){
    mcmc_result = mcmc(X, Y, organize_label(z_mclust), "FALSE", 2, iter, burn)
  }else if (data == "side_lengths"){
    mcmc_result = mcmc(Y, X, organize_label(z_mclust), "FALSE", 2, iter, burn)
  }
  end_time = proc.time()
  time = as.numeric((end_time - start_time)[3], "secs")
  
  
  ## Evaluate clustering results #################################################
  z_ppm <- get.ppm(mcmc_result$z_store, burn, iter, K)$z_ppm
  ppm <- get.ppm(mcmc_result$z_store, burn, iter, K)$ppm
  z_map <- as.vector(mcmc_result$z_map)
  (ari_ppm <-ari(true_cluster, z_ppm))
  (ari_map <- ari(true_cluster, z_map))

  if (software == "R"){
    mcmc_result$z_store =  mcmc_result$z_store - 1
  }
  png(paste0(link, "Result/", "Figure/", data_name, "_", data, "_z_trace_plot.png"), width = 3000, height = 1500, res = 300)
  par(mar = c(4, 4, 0.5, 0.5))
  par(mfrow = c(2, 2))
  for (k in 1:K) {
    plot(rowSums(mcmc_result$z_store == k - 1), type = "l", xlab = "Iteration", ylab = paste0("Number of cluster ", k, " samples"))
    
  }
  dev.off()
  
  ## Evaluate concentration parameter estimates ###################################
  A_store = lapply(1:iter, function(x) mcmc_result$A_store[ , , x])
  B_store = lapply(1:iter, function(x) mcmc_result$B_store[ , , x])
  
  A_hat = Reduce("+", A_store[(burn + 1):iter]) / (iter - burn)
  B_hat = Reduce("+", B_store[(burn + 1):iter]) / (iter - burn)
  
  ## Export mcmc results
  save(mcmc_result, file = paste0(link, "Output/", data_name, "_", data, "_mcmc_result.RData"))
  
  ## Export ppm estimates of z
  write.csv(z_ppm, paste0(link, "Result/", data_name, "_", data, "_z_ppm.csv"), row.names = FALSE)
  
  ## Export ppm values
  write.csv(ppm, paste0(link, "Result/", data_name, "_", data, "_ppm.csv"), row.names = FALSE)
  
  ## Export results
  output = data.frame("data name" = data_name, "data" = data, method = c("K-means", "Hierarchical", "Model-based", "Ours (PPM)", "Ours (MAP)", "Ours"),
                      "metrics" = c(rep("ARI", 5), "time"),
                      "value" = c(ari_kmeans, ari_hclust, ari_mclust, ari_ppm, ari_map, time))
  write.csv(output, paste0(link, "Report/", data_name, "_", data, "_metrics.csv"), row.names = FALSE)
  
  print(output)
  
  message(paste0("----------------------------- ", "Done", "----------------------------- "))
  
}


