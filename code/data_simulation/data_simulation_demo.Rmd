---
title: "Data Simulation and Mapping Demo"
author: "Kevin Jin"
date: "2023-02-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Generate simulated data via polygonal chain simulation

Load essential functions for simulating data.
```{r}
source("~/Documents/Repositories/BACON/code/data_simulation/functions.R")
```

Step 1: Define a function to generate shapes.

```{r}
# x: Total number of shapes in the dataset
# z: Number of clusters in the shape dataset
# n: Number of shapes per cluster
# k: Number of vertices in each shape
# jitter_factor: Amount of jitter to apply to each shape within a cluster
simulate_shapes <- function(x, z, n, k, jitter_factor) {
  dataset <- list()
  for (cluster in 1:z) {
    shape <- generate(k = k)
    shapes <- replicate(n, shape, simplify = FALSE)
    for (i in seq_along(shapes)) {
      shapes[[i]] <- 
        jitter(shapes[[i]], factor = jitter_factor)
    }
    dataset[[length(dataset) + 1]] <- shapes
  }
  return(dataset)
}
```

Step 2: Simulate 5 clusters of a total of 200 3-gons, each cluster having 
10 k-gons each with 0.02 jitter (amount of jitter is modifiable).

```{r}
x <- 200
z <- 10
n <- 20
k <- 3
jitter_factor <- 0.02
dataset <- simulate_shapes(x, z, n, k, jitter_factor)
```


Step 3: For a sanity check, plot each shape to visualize it.
```{r echo=FALSE, eval = FALSE}
for (i in seq_along(dataset)) {
  for (shape in dataset[[i]]) {
    plot(shape, type = "l")
  }
}
```

Step 4: Extract side length and angle proportions as the data to be clustered. 
Creates nested lists for angle proportions and side length proportions.
List structure:
1. Cluster 1
+ Shape 1
+ Shape 2
...
+ Shape 100
2. Cluster 2
...
3. Cluster 10
```{r}
angles <- matrix(nrow = x, ncol = k, byrow = TRUE)
side_lengths <- matrix(nrow = x, ncol = k, byrow = TRUE)

counter <- 1
for (i in seq_along(dataset)) {
  for (j in dataset[[i]]) {
    angles[counter, ] <- get_interior_angles(j)
    side_lengths[counter, ] <- get_side_lengths(j)
    counter <- counter + 1
  }
}

# Clean up variables
rm(i, j)
```

Step 5: Test BACON clustering algorithm.

```{r}
# Source the MCMC algorithm
setwd("~/Documents/Repositories/BACON/code/clustering/")
source("bacon.R")
```

```{r eval = FALSE}
# Cluster dataset with BACON
res <- bacon(side_lengths, 
             angles, 
             K = z,
             weight_L = 0,
             weight_A = 1,
             estimate.s = TRUE, 
             estimate.r = TRUE,
             iter = 10000, 
             burn = 5000)
res$cluster
res$s_map
res$r_map

## Check convergence
plot(rowSums(res$s_store == 0), type = "l", 
     ylab = "Number of samples with starting point as 0", xlab = "Iteration")

## Check clustering accuracy
ground_truth <- rep(1:z, each = n)
mclust::adjustedRandIndex(res$cluster, ground_truth)
```

Test the effect of side length weight on model performance.
```{r echo = FALSE, eval = FALSE}
weight_performance <- as.data.frame(matrix(nrow = 10, ncol = 2, byrow = TRUE))
colnames(weight_performance) <- c("weight", "ari")
ground_truth <- rep(1:z, each = n)
  
row <- 1
for (w in seq(from = 0, to = 1, by = 0.1)) {
  res <- bacon(side_lengths, 
               angles, 
               K = z,
               weight_L = w,
               weight_A = 1,
               estimate.s = FALSE, 
               estimate.r = FALSE,
               iter = 10000, 
               burn = 5000)
  weight_performance[row, "weight"] <- w
  weight_performance[row, "ari"] <- mclust::adjustedRandIndex(res$cluster, 
                                                         ground_truth)
  row <- row + 1
}

plot(weight_performance,
     xlab = "Side Length Weight", 
     ylab = "ARI",
     main = "BACON Performance based on Side Length Weight (200 3-gons)",
     type = "b")
```

Test the effects of both angle weight and side length weight on model
performance.
```{r echo = FALSE}
# x-axis holds the side length weights
# y-axis holds the angle weights
weight_performance <- as.data.frame(matrix(nrow = 21, ncol = 21, byrow = TRUE))
colnames(weight_performance) <- seq(from = 0, to = 2, by = 0.1)
rownames(weight_performance) <- seq(from = 0, to = 2, by = 0.1)
ground_truth <- rep(1:z, each = n)

row <- 1
col <- 1
for (l in seq(from = 0, to = 2, by = 0.1)) {
  for (a in seq(from = 0, to = 2, by = 0.1)) {
    res <- bacon(side_lengths, 
                 angles, 
                 K = z,
                 weight_L = l,
                 weight_A = a,
                 estimate.s = FALSE, 
                 estimate.r = FALSE,
                 iter = 10000, 
                 burn = 5000)
    weight_performance[row, col] <- mclust::adjustedRandIndex(res$cluster, ground_truth)
    col <- col + 1
  }
  row <- row + 1
  col <- 1
}

heatmap(as.matrix(weight_performance[nrow(weight_performance):1, ]),
        margins = c(3.5, 3.5),
        scale = "column",
        Rowv = NA, 
        Colv = NA,
        xlab = "Angle Weight", 
        ylab = "Side Length Weight")

require(pheatmap)
require(grid)
setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.94, height=0.94, name="vp", just=c("right","top"))), action="prepend")
pheatmap(mat = weight_performance,
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         display_numbers = TRUE,
         main = "BACON Performance (n = 200; k = 3; z = 10)",
         xlab = "Angle Weight", 
         ylab = "Side Length Weight",
         scale = "none")
setHook("grid.newpage", NULL, "replace")
grid.text("Angle Weight", y=-0.03, gp=gpar(fontsize = 12))
grid.text("Side Length Weight", x=-0.03, rot=90, gp=gpar(fontsize = 12))
```

Step 6: Reconstruct all closed unit polygonal chains for each shape from the 
side length and angle proportions. 

**WARNING: Computationally intensive!**
Number of possible shapes calculated increases exponentially with the number
of vertices per shape and the number of shapes in the dataset.

```{r}
for (row in 1:nrow(angles)) {
  v <- reconstruct(angles[row, ], side_lengths[row, ])
  plot(data.frame(v[[1]]), type = "l")
  #plot(data.frame(v[[2]]), type = "l")
}
```

# Generate simulated data by drawing from a truncated Dirichlet distribution.

Load essential functions for simulating data.
```{r}
source("~/Documents/Repositories/BACON/code/data_simulation/functions.R")
```

Step 1: Simulate side length and angle proportions for 17 3-gons (Reverse
mapping function seems to add an extra vertex? Is it because it's not closed?):

```{r}
# Generate side length proportions for a dataset of 3-gons
z1_length <- 10
z2_length <- 5
z3_length <- 2
z4_length <- 29
z1 <- rtdirichlet(n = z1_length, eta = c(1, 1, 1), a = c(0, 0, 0), b = c(0.5, 0.5, 0.5))
z2 <- rtdirichlet(n = z2_length, eta = c(2, 1, 2), a = c(0, 0, 0), b = c(0.5, 0.5, 0.5))
z3 <- rtdirichlet(n = z3_length, eta = c(5, 2, 1), a = c(0, 0, 0), b = c(0.5, 0.5, 0.5))
z4 <- rtdirichlet(n = z4_length, eta = c(3, 5, 4), a = c(0, 0, 0), b = c(0.5, 0.5, 0.5))
side_lengths <- rbind(z1, z2, z3, z4)

# Generate angle proportions for a dataset of 3-gons
z1_length <- 10
z2_length <- 5
z3_length <- 2
z4_length <- 29
z1 <- rtdirichlet(n = z1_length, eta = c(1, 1, 1), a = c(0, 0, 0), b = c(0.3, 0.3, 0.3))
z2 <- rtdirichlet(n = z2_length, eta = c(2, 1, 2), a = c(0, 0, 0), b = c(0.3, 0.3, 0.3))
z3 <- rtdirichlet(n = z3_length, eta = c(5, 2, 1), a = c(0, 0, 0), b = c(0.3, 0.3, 0.3))
z4 <- rtdirichlet(n = z4_length, eta = c(3, 5, 4), a = c(0, 0, 0), b = c(0.3, 0.3, 0.3))
angles <- rbind(z1, z2, z3, z4)

# Generate ground truth
ground_truth <- c(rep(1, z1_length), rep(2, z2_length), rep(3, z3_length), rep(4, z4_length))
```

Step 2: Test BACON clustering algorithm.

```{r}
setwd("~/Documents/Repositories/BACON/code/clustering/")
source("bacon.R")
```

```{r}
res <- bacon(side_lengths, 
             angles, 
             K = 4, 
             weight = 1,
             estimate.s = FALSE, 
             estimate.r = FALSE,
             iter = 10000, 
             burn = 5000)
res$cluster
res$s_map
res$r_map

## Check convergence
plot(rowSums(res$s_store == 0), type = "l", 
     ylab = "Number of samples with starting point as 0", xlab = "Iteration")

## Check clustering accuracy
mclust::adjustedRandIndex(res$cluster, ground_truth)
```

Step 3: Reconstruct all closed unit polygonal chains for each shape from the 
side length and angle proportions. 

```{r}
for (i in 1:nrow(angles)) {
  assign(paste0("pc_", i), reconstruct(angles[i, ], side_lengths[i, ]))
}
```